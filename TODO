ppt reveal.js
1.react生命周期，react-router
2.import {} 和不加{}的区别，
3.react-media
4.componentWillUnmount清除定时器很好理解，另外一个用法this._mounted
5.canvas操作需要涉及到dom，必须放在willmount
6.https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html  三个生命周期废除 react异步渲染http://www.karmagut.me/?p=288
7.willmount 和 didmount区别 https://segmentfault.com/q/1010000008133309，和redux的dispatch发送action时机做一下比较
8.setState https://zhuanlan.zhihu.com/p/39512941
9.阮一峰event loop http://www.ruanyifeng.com/blog/2014/10/event-loop.html




正文语言组织
setState react 11 之前不能在componentWillmount调用


Calls to setState in life-cycle methods are now always batched and therefore asynchronous. Previously the first call on the first mount was synchronous.
setState and forceUpdate on an unmounted component now warns instead of throwing. That avoids a possible race condition with Promises.

1.合成事件的setState
React合成事件理解
如果DOM上绑定了过多的事件处理函数，整个页面响应以及内存占用可能都会受到影响。React为了避免这类DOM事件滥用，同时屏蔽底层不同浏览器之间的事件系统差异，实现了一个中间层——SyntheticEvent。

当用户在为onClick添加函数时，React并没有将Click时间绑定在DOM上面。
而是在document处监听所有支持的事件，当事件发生并冒泡至document处时，React将事件内容封装交给中间层SyntheticEvent（负责所有事件合成）
所以当事件触发的时候，对使用统一的分发函数dispatchEvent将指定函数执行。


合成事件的处理逻辑
try {
    return fn(a, b);
  } finally {
    isBatchingInteractiveUpdates = previousIsBatchingInteractiveUpdates;
    isBatchingUpdates = previousIsBatchingUpdates;
    if (!isBatchingUpdates && !isRendering) {
      performSyncWork();
    }
  }
2.生命周期的setState
state = { 
    val: 0 
}
componentDidMount() {
    this.setState({ val: this.state.val + 1 })
    console.log(this.state.val) // 输出的还是更新前的值 --> 0
 }
不管是componentDidmount还是componentWillmount，都是钩子执行完再去走更新逻辑。



https://codepen.io/mrscobbler/pen/JEoEgN/ setState同步异步
this.setState({
  plateNumber:'123456',
}, () => {
  console.log(this.state.plateNumber); 
})